"""
Ïª§Ïä§ÌÖÄ TLS ÌÅ¨Î°§Îü¨ Î™®Îìà
curl-cffi JA3 fingerprintÎ•º ÏÇ¨Ïö©Ìïú TLS Í∏∞Î∞ò ÌÅ¨Î°§ÎßÅ
"""

import sys
import os
import time
from urllib.parse import quote

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏Î•º Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from curl_cffi import requests
from curl_cffi.requests import Session
from lib.device.tls_builder import load_fingerprint_data
from lib.logs.checkpoint import Checkpoint
from lib.product_extractor import ProductExtractor


def delete_blocked_cookies(device_name, worker_id=None):
    """
    Ï∞®Îã®Îêú Ïø†ÌÇ§ ÌååÏùº ÏÇ≠Ï†ú

    Args:
        device_name: ÎîîÎ∞îÏù¥Ïä§ Ïù¥Î¶Ñ
        worker_id: Worker ID (NoneÏù¥Î©¥ ÏõêÎ≥∏ Ïø†ÌÇ§ ÏÇ≠Ï†úÌïòÏßÄ ÏïäÏùå)
    """
    safe_device_name = device_name.replace(' ', '_').replace('/', '_')
    # lib/crawler/ ‚Üí lib/ ‚Üí ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏
    fingerprint_dir = os.path.join(
        os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
        'data',
        'fingerprints',
        safe_device_name
    )

    if worker_id is not None:
        # WorkerÏö© Ïø†ÌÇ§Îßå ÏÇ≠Ï†ú
        cookies_file = os.path.join(fingerprint_dir, f'cookies_packet_{worker_id}.json')
        if os.path.exists(cookies_file):
            os.remove(cookies_file)
            print(f"\n  üóëÔ∏è Worker {worker_id} Ïø†ÌÇ§ ÏÇ≠Ï†úÎê® (Ï∞®Îã® Í∞êÏßÄ)")
            return True
    else:
        # ÏõêÎ≥∏ Ïø†ÌÇ§Îäî ÏÇ≠Ï†úÌïòÏßÄ ÏïäÏùå (Îã®Ïùº worker Î™®ÎìúÏóêÏÑúÎèÑ ÏõêÎ≥∏ Ïú†ÏßÄ)
        print(f"\n  ‚ö†Ô∏è Ï∞®Îã® Í∞êÏßÄ - Ïø†ÌÇ§ Ïû¨ÏàòÏßë ÌïÑÏöî")

    return False


class CustomTLSCrawler:
    """Ïª§Ïä§ÌÖÄ TLS ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¨Î°§Îü¨"""

    def __init__(self, device_name, browser, device_config=None, worker_id=None):
        """
        Args:
            device_name: ÎîîÎ∞îÏù¥Ïä§ Ïù¥Î¶Ñ
            browser: Î∏åÎùºÏö∞Ï†Ä Ïù¥Î¶Ñ (safari, chrome, chromium Îì±)
            device_config: ÎîîÎ∞îÏù¥Ïä§ ÏÑ§Ï†ï dict (os_version Ï∂îÏ∂úÏö©, NoneÏù¥Î©¥ Î†àÍ±∞Ïãú Î™®Îìú)
            worker_id: Worker ID (Î≥ëÎ†¨ ÌÅ¨Î°§ÎßÅÏö©, NoneÏù¥Î©¥ ÏõêÎ≥∏ Ïø†ÌÇ§ ÏÇ¨Ïö©)
        """
        self.device_name = device_name
        self.browser = browser
        self.os_version = device_config.get('os_version') if device_config else None
        self.worker_id = worker_id
        self.session = Session()  # TLS Ïó∞Í≤∞ Ïû¨ÏÇ¨Ïö© + Ïø†ÌÇ§ ÏûêÎèô Í¥ÄÎ¶¨

        # ÌÅ¨Î°§ÎßÅ ÏÑ∏ÏÖò ID ÏÉùÏÑ± (Ïø†ÌÇ§ Ï∂îÏ†ÅÏö©)
        from datetime import datetime
        self.session_id = datetime.now().strftime('%Y%m%d_%H%M%S')

    def crawl_page(self, keyword='ÏïÑÏù¥Ìè∞', page=1, max_retries=None):
        """
        Îã®Ïùº ÌéòÏù¥ÏßÄ ÌÅ¨Î°§ÎßÅ

        ÏõêÎ≥∏ Ïø†ÌÇ§Îäî ÏàòÏ†ïÌïòÏßÄ ÏïäÍ≥† Îß§Î≤à fingerprintÏóêÏÑú Î°úÎìúÌïòÏó¨ ÏÇ¨Ïö©

        Args:
            keyword: Í≤ÄÏÉâ ÌÇ§ÏõåÎìú
            page: ÌéòÏù¥ÏßÄ Î≤àÌò∏
            max_retries: HTTP2 ÌîÑÎ°úÌÜ†ÏΩú ÏóêÎü¨ Ïãú Ïû¨ÏãúÎèÑ ÌöüÏàò (NoneÏù¥Î©¥ ÏûêÎèô ÏÑ§Ï†ï)
                        - Î¶¨Ïñº Í∏∞Í∏∞ (worker_id=None): 1Ìöå (Ïû¨ÏãúÎèÑ Î∂àÌïÑÏöî)
                        - Ìå®ÌÇ∑ Î™®Îìú (worker_id ÏûàÏùå): 5Ìöå (ÌïúÏàúÍ∞Ñ ÌíÄÎ¶¥ Ïàò ÏûàÏùå)

        Returns:
            dict: {
                'success': bool,
                'keyword': str,
                'page': int,
                'ranking': list,
                'ads': list,
                'total': int
            }
        """

        # max_retries ÏûêÎèô ÏÑ§Ï†ï (HTTP2 ÏóêÎü¨ ÎåÄÎπÑ)
        if max_retries is None:
            max_retries = 3  # HTTP2 ÏóêÎü¨ Ïãú 3Ìöå Ïó∞ÏÜç Ïã§Ìå®ÍπåÏßÄ Ïû¨ÏãúÎèÑ

        mode_label = f"Ìå®ÌÇ∑ Î™®Îìú (Worker {self.worker_id})" if self.worker_id else "Î¶¨Ïñº Í∏∞Í∏∞ Î™®Îìú"

        print("\n" + "="*60)
        print(f"curl-cffi Ïª§Ïä§ÌÖÄ TLS ÌÅ¨Î°§ÎßÅ - ÌéòÏù¥ÏßÄ {page}")
        print("="*60)
        print(f"Í≤ÄÏÉâ ÌÇ§ÏõåÎìú: {keyword}")
        print(f"ÌéòÏù¥ÏßÄ: {page}")
        print(f"Î™®Îìú: {mode_label} (ÏµúÎåÄ ÏãúÎèÑ: {max_retries}Ìöå, HTTP2 ÏóêÎü¨ Ïãú 3Ï¥àÎßàÎã§ Ïû¨ÏãúÎèÑ)")
        print("="*60 + "\n")

        # 1. Fingerprint Îç∞Ïù¥ÌÑ∞ Î°úÎìú (Îß§Î≤à ÏõêÎ≥∏ÏóêÏÑú Î°úÎìú)
        worker_label = f" [Worker {self.worker_id}]" if self.worker_id else ""
        print(f"[STEP 1] Fingerprint Îç∞Ïù¥ÌÑ∞ Î°úÎìú{worker_label}")
        data = load_fingerprint_data(self.device_name, self.browser, self.os_version, worker_id=self.worker_id)

        # Ïø†ÌÇ§Îäî DBÏóêÏÑú Î®ºÏ†Ä ÏãúÎèÑ, ÏóÜÏúºÎ©¥ ÌååÏùºÏóêÏÑú Î°úÎìú
        cookies = []
        cookie_source = "ÌååÏùº"

        try:
            from lib.db.manager import DBManager
            db = DBManager()
            cookie_record = db.get_latest_original_cookie(self.device_name, self.browser, self.os_version)

            if cookie_record:
                import json
                cookies = json.loads(cookie_record[4])  # cookie_data Ïª¨Îüº (index 4)
                cookie_source = "DB"
        except Exception as e:
            print(f"  ‚ö†Ô∏è  DB Ïø†ÌÇ§ Î°úÎìú Ïã§Ìå®: {e}")

        # DBÏóê ÏóÜÏúºÎ©¥ ÌååÏùºÏóêÏÑú Î°úÎìú
        if not cookies:
            cookies = data.get('cookies', [])
            cookie_source = "ÌååÏùº"

        headers = data.get('headers', {})
        tls = data.get('tls', {})

        # [FINAL] Ïø†ÌÇ§ Í¥ÄÎ¶¨ Ï†ÑÎûµ - PCID, sid Î™®Îëê ÏõêÎ≥∏ Ïú†ÏßÄ
        # Í≤∞Î°†: sidÎäî ÏÑúÎ≤ÑÏóêÏÑú /n-api/recommend/feeds Ìò∏Ï∂ú Ïãú Î∞úÍ∏âÎêòÎäî Ï§ëÏöîÌïú ÏÑ∏ÏÖò Ï†ïÎ≥¥
        #       PCIDÏôÄ sidÎäî Ïåç(pair)ÏúºÎ°ú Ïú†ÏßÄÎêòÏñ¥Ïïº Ìï®
        #       Îëò Îã§ BrowserStack ÏàòÏßëÍ∞í Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© = Ïú†Ìö®Ìïú ÏÑ∏ÏÖò

        # Î™®Îì† Ïø†ÌÇ§ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© (PCID, sid Ìè¨Ìï®)
        cookie_dict = {
            c['name']: c['value']
            for c in cookies
        }

        if page == 1:
            has_pcid = 'PCID' in cookie_dict
            has_sid = 'sid' in cookie_dict
            print(f"  ‚úì Ïø†ÌÇ§: {len(cookie_dict)}Í∞ú (Ï∂úÏ≤ò: {cookie_source})")
            print(f"      PCID: {'ÏûàÏùå ‚úÖ' if has_pcid else 'ÏóÜÏùå ‚ùå'}")
            print(f"      sid: {'ÏûàÏùå ‚úÖ' if has_sid else 'ÏóÜÏùå ‚ùå'}")
        else:
            # Session Ïø†ÌÇ§ ÌôïÏù∏ (curl-cffi SessionÏù¥ ÏûêÎèô Í¥ÄÎ¶¨)
            session_cookie_count = len(self.session.cookies) if hasattr(self.session, 'cookies') else 0
            print(f"  ‚úì Ïø†ÌÇ§: Session ÏûêÎèô Í¥ÄÎ¶¨ Ï§ë")
            print(f"      Session Ïø†ÌÇ§: {session_cookie_count}Í∞ú (1ÌéòÏù¥ÏßÄ Set-Cookie Ìè¨Ìï®)")
            print()

        print(f"  ‚úì TLS Ï†ïÎ≥¥: Î°úÎìú ÏôÑÎ£å")

        # browserleaks ÌòïÏãùÍ≥º peet.ws ÌòïÏãù Î™®Îëê ÏßÄÏõê
        # peet.ws: data['tls'] = {'tls': {...}, 'http2': {...}}
        # browserleaks: data['tls'] = {...}, data['http2'] = {...}
        if 'ja3' in tls:
            # browserleaks ÌòïÏãù: tlsÍ∞Ä Î∞îÎ°ú TLS Îç∞Ïù¥ÌÑ∞
            tls_data = tls
            http2_data = data.get('http2', {})
        else:
            # peet.ws ÌòïÏãù: tls ÏïàÏóê tls/http2Í∞Ä Ï§ëÏ≤©
            tls_data = tls.get('tls', tls)
            http2_data = tls.get('http2', {})

        # cipher_suites (full format) ÎòêÎäî ciphers (minimal format)
        cipher_list = tls_data.get('cipher_suites', tls_data.get('ciphers', []))
        print(f"  ‚úì JA3 Hash: {tls_data.get('ja3_hash', 'N/A')}")
        print(f"  ‚úì Cipher Suites: {len(cipher_list)}Í∞ú")
        print()

        # 2. JA3 / Akamai / extra_fp Ï∂îÏ∂ú
        print("[STEP 2] TLS Fingerprint Ï∂îÏ∂ú")
        ja3 = tls_data.get('ja3', '')
        akamai = http2_data.get('akamai_fingerprint', '')

        if not ja3:
            raise ValueError("JA3 fingerprintÍ∞Ä ÏóÜÏäµÎãàÎã§.")

        print(f"  ‚úì JA3: {ja3[:60]}...")
        if akamai:
            print(f"  ‚úì Akamai: {akamai}")

        # extra_fp Íµ¨ÏÑ± (Í∞úÏÑ†Îêú Ï†ÑÏ≤¥ ÏòµÏÖò)
        extra_fp = {}

        # 1) TLS GREASE Í∞êÏßÄ (Chrome ÌïÑÏàò!)
        # cipher ÌòïÏãù ÌôïÏù∏: Í∞ùÏ≤¥ Î∞∞Ïó¥ vs ID Î¨∏ÏûêÏó¥ Î∞∞Ïó¥
        has_grease = False
        if cipher_list:
            if isinstance(cipher_list[0], dict):
                # Full format: {"id": 10794, "name": "GREASE"}
                has_grease = any('GREASE' in c.get('name', '') for c in cipher_list)
            else:
                # Minimal format: ["4865", "4866", ...]
                has_grease = any('GREASE' in str(c) or '0x' in str(c) for c in cipher_list)

        if has_grease:
            extra_fp['tls_grease'] = True
            print(f"  ‚úì TLS GREASE: ÌôúÏÑ±Ìôî (Chrome ÌäπÏßï)")

        # 2) signature_algorithms Ï∂îÏ∂ú
        extensions = tls_data.get('extensions', [])

        # extensions ÌòïÏãù ÌôïÏù∏: Í∞ùÏ≤¥ Î∞∞Ïó¥ vs ID Î¨∏ÏûêÏó¥ Î∞∞Ïó¥
        has_extension_objects = (extensions and
                                isinstance(extensions, list) and
                                len(extensions) > 0 and
                                isinstance(extensions[0], dict))

        if has_extension_objects:
            # Full structure: extension Í∞ùÏ≤¥ Î∞∞Ïó¥ (browserleaks full format)
            for ext in extensions:
                ext_name = ext.get('name', '')
                ext_data = ext.get('data', {})

                # signature_algorithms
                if ext_name == 'signature_algorithms':
                    algorithms = ext_data.get('algorithms', [])
                    if algorithms:
                        # ÏïåÍ≥†Î¶¨Ï¶ò ID Î¶¨Ïä§Ìä∏ Ï∂îÏ∂ú
                        algo_ids = [str(a.get('id', a)) if isinstance(a, dict) else str(a) for a in algorithms]
                        extra_fp['tls_signature_algorithms'] = algo_ids
                        print(f"  ‚úì Signature Algorithms: {len(algo_ids)}Í∞ú")

                # compress_certificate
                elif ext_name == 'compress_certificate':
                    algorithms = ext_data.get('algorithms', [])
                    if algorithms:
                        # Ï≤´ Î≤àÏß∏ ÏïåÍ≥†Î¶¨Ï¶ò Ïù¥Î¶Ñ Ï∂îÏ∂ú
                        algo = algorithms[0]
                        if isinstance(algo, dict):
                            algo_name = algo.get('name', '').lower()
                        else:
                            algo_name = str(algo).split()[0].lower()
                        if algo_name:
                            extra_fp['tls_cert_compression'] = algo_name
                            print(f"  ‚úì Certificate Compression: {algo_name}")

                # supported_versions
                elif ext_name == 'supported_versions':
                    versions = ext_data.get('supported_versions', [])
                    if versions:
                        # GREASE Ï†úÏô∏ÌïòÍ≥† Ïã§Ï†ú Î≤ÑÏ†Ñ ÌôïÏù∏
                        real_versions = [v.get('name', v) if isinstance(v, dict) else v
                                       for v in versions
                                       if 'GREASE' not in str(v)]
                        if any('TLS 1.2' in str(v) for v in real_versions):
                            extra_fp['tls_min_version'] = 4  # CurlSslVersion.TLSv1_2
                            print(f"  ‚úì TLS Min Version: TLSv1.2")
        else:
            # Minimal structure: extension ID Î¨∏ÏûêÏó¥ Î∞∞Ïó¥ (parsed from JA3)
            print(f"  ‚ÑπÔ∏è  Extensions: IDÎßå Ìè¨Ìï® (ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÏóÜÏùå, {len(extensions)}Í∞ú)")
            # IDÎßåÏúºÎ°úÎäî ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú Î∂àÍ∞Ä, Í∏∞Î≥∏ ÏÑ§Ï†ï ÏÇ¨Ïö©

        # 5) Extension ÏàúÏÑú ÏôÑÏ†Ñ Í≥†Ï†ï
        extra_fp['tls_permute_extensions'] = False  # ÎûúÎç§Ìôî ÎπÑÌôúÏÑ±Ìôî

        # JA3 stringÏóê Ïù¥ÎØ∏ extensions ÏàúÏÑúÍ∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùå
        # Ìè¨Îß∑: SSLVersion,Ciphers,Extensions,EllipticCurves,EllipticCurvePointFormats
        ja3_parts = ja3.split(',')
        if len(ja3_parts) >= 3:
            extensions_part = ja3_parts[2]  # Extensions Î∂ÄÎ∂Ñ
            print(f"  ‚úì Extensions ÏàúÏÑú: Í≥†Ï†ï (JA3: {extensions_part[:40]}...)")
        else:
            print(f"  ‚úì Extensions ÏàúÏÑú: Í≥†Ï†ï (permute=False)")

        # 6) ALPN Ï∂îÏ∂ú (JA3Ïóê Ìè¨Ìï® Ïïà Îê® - Î≥ÑÎèÑ ÏÑ§Ï†ï ÌïÑÏàò!)
        alpn_protocols = None
        if has_extension_objects:
            for ext in extensions:
                ext_name = ext.get('name', '').lower()
                if 'application_layer_protocol' in ext_name:
                    ext_data = ext.get('data', {})
                    alpn_protocols = ext_data.get('protocol_name_list', [])
                    if alpn_protocols:
                        print(f"  ‚úì ALPN: {', '.join(alpn_protocols)}")
                    break

        # 7) HTTP/2 priority Ï∂îÏ∂ú
        sent_frames = http2_data.get('sent_frames', [])
        for frame in sent_frames:
            if frame.get('frame_type') == 'HEADERS' and 'priority' in frame:
                priority = frame['priority']
                extra_fp['http2_stream_weight'] = priority.get('weight', 256)
                extra_fp['http2_stream_exclusive'] = priority.get('exclusive', 1)
                print(f"  ‚úì HTTP/2 Priority: weight={extra_fp['http2_stream_weight']}, exclusive={extra_fp['http2_stream_exclusive']}")
                break

        # 8) HTTP/2 Priority ÌîÑÎ†àÏûÑ ÏÇ¨Ïö© (no_priority ÎπÑÌôúÏÑ±Ìôî)
        extra_fp['http2_no_priority'] = False

        # ÎîîÎ≤ÑÍπÖ: extra_fp Ï†ÑÏ≤¥ Ï∂úÎ†•
        print(f"\n  [extra_fp ÏÑ§Ï†ï ÏöîÏïΩ]")
        for key, value in extra_fp.items():
            if key == 'tls_signature_algorithms':
                print(f"    ‚Ä¢ {key}: {len(value)}Í∞ú ÏïåÍ≥†Î¶¨Ï¶ò")
            else:
                print(f"    ‚Ä¢ {key}: {value}")

        if alpn_protocols:
            print(f"    ‚Ä¢ ALPN (Î≥ÑÎèÑ): {alpn_protocols}")

        print()

        # 3. curl-cffi ÏöîÏ≤≠ (JA3 Î∞©Ïãù, Ïû¨ÏãúÎèÑ Î°úÏßÅ Ìè¨Ìï®)
        print("[STEP 3] curl-cffi JA3 TLS ÏöîÏ≤≠")

        # Í≤ÄÏÉâ URL ÏÉùÏÑ± (ÏßÅÏ†ë Ï†ëÏÜç Ïãú ÏÑúÎ≤ÑÍ∞Ä PCID, sid ÏûêÎèô Î∞úÍ∏â)
        search_url = f"https://www.coupang.com/np/search?q={quote(keyword)}&page={page}"
        print(f"  URL: {search_url}")
        print(f"  ÏµúÎåÄ ÏãúÎèÑ: {max_retries}Ìöå (Ïã§Ìå® Ïãú 3Ï¥àÎßàÎã§ Ïû¨ÏãúÎèÑ)\n")

        # Referer ÏÑ§Ï†ï (Î™®Îì† ÌéòÏù¥ÏßÄ)
        if page == 1:
            # 1ÌéòÏù¥ÏßÄ: Î©îÏù∏ ÌéòÏù¥ÏßÄÏóêÏÑú Í≤ÄÏÉâÌïú Í≤ÉÏ≤òÎüº
            headers['Referer'] = 'https://www.coupang.com/'
            headers['Sec-Fetch-Site'] = 'same-origin'
            print(f"  Referer: https://www.coupang.com/ (Î©îÏù∏ ÌéòÏù¥ÏßÄ)")
        else:
            # 2ÌéòÏù¥ÏßÄ Ïù¥ÏÉÅ: Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄ URL
            prev_url = f"https://www.coupang.com/np/search?q={quote(keyword)}&page={page-1}"
            headers['Referer'] = prev_url
            headers['Sec-Fetch-Site'] = 'same-origin'
            print(f"  Referer: {prev_url[:60]}...")

        status_code = None
        response_text = None
        last_error = None

        for attempt in range(1, max_retries + 1):
            try:
                if attempt > 1:
                    # HTTP2 ÏóêÎü¨ Ïû¨ÏãúÎèÑ ÎåÄÍ∏∞ (3Ï¥à)
                    wait_time = 3
                    print(f"  ‚è≥ Ïû¨ÏãúÎèÑ {attempt}/{max_retries} (ÎåÄÍ∏∞ {wait_time}Ï¥à)...")
                    time.sleep(wait_time)

                # [ÎîîÎ≤ÑÍπÖ] ÏöîÏ≤≠ Ìó§Îçî ÌôïÏù∏
                print(f"\n[ÎîîÎ≤ÑÍπÖ] ÏöîÏ≤≠ Ìó§Îçî (ÌéòÏù¥ÏßÄ {page}):")
                print(f"  {'='*56}")
                for key, value in list(headers.items())[:15]:  # ÏµúÎåÄ 15Í∞ú
                    print(f"  {key}: {str(value)[:60]}")
                print(f"  {'='*56}\n")

                # JA3 Î∞©ÏãùÏúºÎ°ú ÏöîÏ≤≠ (Session ÏÇ¨Ïö© - TLS Ïó∞Í≤∞ Ïû¨ÏÇ¨Ïö©)
                # ALPN ÏÑ§Ï†ï Î∞©Î≤ï (curl-cffi Î≤ÑÏ†ÑÏóê Îî∞Îùº Îã§Î•º Ïàò ÏûàÏùå):
                # ÏòµÏÖò 1: alpn ÌååÎùºÎØ∏ÌÑ∞ (ÏßÄÏõê Ïãú)
                # ÏòµÏÖò 2: http_version="v2" (h2 Í∞ïÏ†ú)
                # ÏòµÏÖò 3: akamai fingerprintÍ∞Ä ALPN Ìè¨Ìï® (Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ë)

                # [FINAL] Ïø†ÌÇ§ Ï†ÑÎã¨ Ï†ÑÎûµ - PCID, sid ÏõêÎ≥∏ Ïú†ÏßÄ (ÏÑúÎ≤Ñ Î∞úÍ∏âÍ∞í ÏÇ¨Ïö©)
                request_params = {
                    'ja3': ja3,
                    'akamai': akamai if akamai else None,
                    'extra_fp': extra_fp if extra_fp else None,
                    'headers': headers,
                    'cookies': cookie_dict if page == 1 else None,  # Ï≤´ ÌéòÏù¥ÏßÄÎßå Ï†ÑÎã¨, Ïù¥ÌõÑ Session ÏûêÎèô
                    'timeout': 30,
                    'verify': True
                }

                print(f"  [Ïø†ÌÇ§ Ï†ÑÎûµ] PCID, sid ÏõêÎ≥∏ Ïú†ÏßÄ (ÏÑúÎ≤Ñ Î∞úÍ∏âÍ∞í)")
                if page == 1:
                    print(f"      Ï≤´ ÌéòÏù¥ÏßÄ - Ïø†ÌÇ§ {len(cookie_dict)}Í∞ú Ï†ÑÎã¨")
                    has_pcid = 'PCID' in cookie_dict
                    has_sid = 'sid' in cookie_dict
                    print(f"          PCID: {'Ï†ÑÎã¨ ‚úÖ' if has_pcid else 'ÏóÜÏùå ‚ùå'}")
                    print(f"          sid: {'Ï†ÑÎã¨ ‚úÖ' if has_sid else 'ÏóÜÏùå ‚ùå'}")
                else:
                    session_count = len(self.session.cookies) if hasattr(self.session, 'cookies') else 0
                    print(f"      Session Ïø†ÌÇ§: {session_count}Í∞ú (ÏûêÎèô Ï†ÑÎã¨)")

                # HTTP/2 Í∞ïÏ†ú (ALPN h2 ÏûêÎèô ÏÑ§Ï†ï)
                if alpn_protocols and 'h2' in alpn_protocols:
                    request_params['http_version'] = 'v2'

                # ALPN Î™ÖÏãúÏ†Å ÏÑ§Ï†ï ÏãúÎèÑ (curl-cffi Î≤ÑÏ†ÑÏóê Îî∞Îùº ÏßÄÏõê Ïó¨Î∂Ä Îã§Î¶Ñ)
                # Ï£ºÏÑù: ÏßÄÏõêÎêòÏßÄ ÏïäÏúºÎ©¥ ÏóêÎü¨ Î∞úÏÉùÌï† Ïàò ÏûàÏùå
                # if alpn_protocols:
                #     try:
                #         request_params['alpn'] = alpn_protocols
                #     except:
                #         pass  # alpn ÌååÎùºÎØ∏ÌÑ∞ ÎØ∏ÏßÄÏõê Ïãú Î¨¥Ïãú

                # ÏùëÎãµ ÏãúÍ∞Ñ Ï∏°Ï†ï ÏãúÏûë
                import time as time_module
                request_start_time = time_module.time()

                response = self.session.get(search_url, **request_params)

                # ÏùëÎãµ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (ms)
                response_time_ms = int((time_module.time() - request_start_time) * 1000)

                status_code = response.status_code
                response_text = response.text
                response_size_bytes = len(response.content) if hasattr(response, 'content') else len(response_text)

                # [ÎîîÎ≤ÑÍπÖ] Set-Cookie Ìó§Îçî Ï†ÑÏ≤¥ Î∂ÑÏÑù
                session_cookie_names = ['PCID', 'sid', 'sessionid', 'session', 'JSESSIONID']
                received_cookies = []

                # ÏùëÎãµÏóêÏÑú ÏàòÏã†Îêú ÏÑ∏ÏÖò Ïø†ÌÇ§ ÌôïÏù∏
                for cookie_name in session_cookie_names:
                    if cookie_name in response.cookies:
                        received_cookies.append(cookie_name)

                print(f"\n[ÎîîÎ≤ÑÍπÖ] Set-Cookie Î∂ÑÏÑù (ÌéòÏù¥ÏßÄ {page}):")
                print(f"  {'='*56}")

                # 1. response.cookies ÌôïÏù∏
                all_response_cookies = dict(response.cookies)
                print(f"  [1] response.cookies: {len(all_response_cookies)}Í∞ú")
                for name, value in all_response_cookies.items():
                    print(f"      - {name}: {str(value)[:40]}...")

                # 2. Set-Cookie Ìó§Îçî ÏßÅÏ†ë ÌôïÏù∏ (Îã§ÏñëÌïú Î∞©Î≤ïÏúºÎ°ú)
                if hasattr(response, 'headers'):
                    print(f"\n  [2] Set-Cookie Ìó§Îçî Î∂ÑÏÑù:")

                    # Î∞©Î≤ï 1: get_list()
                    set_cookie_headers = []
                    if hasattr(response.headers, 'get_list'):
                        set_cookie_headers = response.headers.get_list('Set-Cookie')

                    # Î∞©Î≤ï 2: get()
                    if not set_cookie_headers and hasattr(response.headers, 'get'):
                        single_header = response.headers.get('Set-Cookie')
                        if single_header:
                            set_cookie_headers = [single_header]

                    # Î∞©Î≤ï 3: getlist() (ÏÜåÎ¨∏Ïûê)
                    if not set_cookie_headers and hasattr(response.headers, 'getlist'):
                        set_cookie_headers = response.headers.getlist('Set-Cookie')

                    # Î∞©Î≤ï 4: ÏßÅÏ†ë ÏàúÌöå
                    if not set_cookie_headers:
                        try:
                            for key, value in response.headers.items():
                                if key.lower() == 'set-cookie':
                                    set_cookie_headers.append(value)
                        except:
                            pass

                    if set_cookie_headers:
                        print(f"      Ï¥ù {len(set_cookie_headers)}Í∞ú Î∞úÍ≤¨")
                        for i, header in enumerate(set_cookie_headers[:10], 1):  # ÏµúÎåÄ 10Í∞ú
                            cookie_name = header.split('=')[0] if '=' in header else 'unknown'
                            # sid ÌôïÏù∏
                            if 'sid=' in header:
                                print(f"      {i}. {cookie_name}: {header[:80]}... ‚úÖ sid Î∞úÍ≤¨!")
                            else:
                                print(f"      {i}. {cookie_name}: {header[:60]}...")
                    else:
                        print(f"      ‚ùå Set-Cookie Ìó§Îçî ÏóÜÏùå (Î™®Îì† Î∞©Î≤ï ÏãúÎèÑÌñàÏúºÎÇò Î∞úÍ≤¨ Î™ªÌï®)")

                        # Ï†ÑÏ≤¥ Ìó§Îçî ÌôïÏù∏
                        print(f"\n      [Ï†ÑÏ≤¥ ÏùëÎãµ Ìó§Îçî ÌôïÏù∏]")
                        try:
                            all_headers = dict(response.headers)
                            for key in list(all_headers.keys())[:10]:
                                print(f"        - {key}: {str(all_headers[key])[:50]}...")
                        except:
                            print(f"        (Ìó§Îçî Ï∂úÎ†• Ïã§Ìå®)")

                # 3. Session.cookies ÌôïÏù∏
                if hasattr(self.session, 'cookies'):
                    session_cookies_count = len(self.session.cookies)
                    print(f"\n  [3] Session.cookies (ÏûêÎèô Ï†ÄÏû•): {session_cookies_count}Í∞ú")

                    # PCID ÌôïÏù∏
                    if 'PCID' in self.session.cookies:
                        pcid = self.session.cookies.get('PCID', '')
                        print(f"      - PCID: {str(pcid)[:40]}... ‚úÖ")
                    else:
                        print(f"      - PCID: ‚ùå ÏóÜÏùå")

                    # sid ÌôïÏù∏
                    if 'sid' in self.session.cookies:
                        sid = self.session.cookies.get('sid', '')
                        print(f"      - sid: {str(sid)[:40]}... ‚úÖ")
                    else:
                        print(f"      - sid: ‚ùå ÏóÜÏùå")

                print(f"  {'='*56}\n")

                # Í≤∞Í≥º ÏöîÏïΩ
                if received_cookies:
                    print(f"  ‚úì ÏÑ∏ÏÖò Ïø†ÌÇ§ ÏàòÏã†: {', '.join(received_cookies)}")
                else:
                    print(f"  ‚ö†Ô∏è  PCID, sid ÎØ∏ÏàòÏã† (ÏÑúÎ≤ÑÏóêÏÑú Î∞úÍ∏â Ïïà Ìï®)")

                # [ÎîîÎ≤ÑÍπÖ] Ïã§Ï†ú Ï†ÑÏÜ°Îêú TLS fingerprint ÌôïÏù∏ (extensions ÏàúÏÑú Í≤ÄÏ¶ù)
                # Ï∞∏Í≥†: curl-cffi SessionÏùÄ ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú JA3Î•º ÏÇ¨Ïö©ÌïòÎØÄÎ°ú
                # Ïã§Ï†ú Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ÏóêÏÑú extensions ÏàúÏÑúÍ∞Ä Í≥†Ï†ïÎêòÏñ¥Ïïº Ìï®
                print(f"\n  [TLS Í≤ÄÏ¶ù] Ï†ÑÏÜ°Îêú JA3 Hash: {tls_data.get('ja3_hash', 'N/A')}")
                print(f"  [TLS Í≤ÄÏ¶ù] tls_permute_extensions: False (Í≥†Ï†ï)")
                print(f"  [TLS Í≤ÄÏ¶ù] Extensions Ïàò: {len(extensions)}Í∞ú")

                # [ÌÖåÏä§Ìä∏Ïö©] Akamai Ïø†ÌÇ§ ÏóÖÎç∞Ïù¥Ìä∏ (ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÌôúÏÑ±Ìôî)
                from lib.utils.akamai_updater import update_akamai_cookies, is_enabled
                if is_enabled():
                    result = update_akamai_cookies(self.device_name, self.browser, response.cookies, self.worker_id)
                    if result['updated']:
                        print(f"  üîÑ Akamai Ïø†ÌÇ§ ÏóÖÎç∞Ïù¥Ìä∏: {', '.join(result['cookies'])} ({result['count']}Í∞ú)")
                    # ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®Îäî Ï°∞Ïö©Ìûà Î¨¥Ïãú (ÌÖåÏä§Ìä∏Ïö©Ïù¥ÎØÄÎ°ú)

                print(f"  ‚úì ÏùëÎãµ ÏàòÏã† (ÏãúÎèÑ {attempt}/{max_retries})\n")
                break  # ÏÑ±Í≥µÌïòÎ©¥ Î£®ÌîÑ Ï¢ÖÎ£å

            except Exception as e:
                last_error = e
                error_msg = str(e).lower()

                # HTTP2 ÌîÑÎ°úÌÜ†ÏΩú ÏóêÎü¨ ÌôïÏù∏
                is_http2_error = 'http2' in error_msg or 'protocol' in error_msg or 'stream' in error_msg

                # ÏóêÎü¨ Î©îÏãúÏßÄ Í∞ÑÍ≤∞Ìôî
                if 'curl: (92)' in str(e):
                    error_short = "INTERNAL_ERROR (curl 92)"
                elif 'curl:' in str(e):
                    import re
                    match = re.search(r'curl: \((\d+)\)', str(e))
                    if match:
                        error_short = f"curl error {match.group(1)}"
                    else:
                        error_short = str(e)[:60]
                else:
                    error_short = str(e)[:60]

                # HTTP2 ÏóêÎü¨Í∞Ä ÏïÑÎãàÎ©¥ Ïû¨ÏãúÎèÑ ÏóÜÏù¥ Î∞îÎ°ú Ïã§Ìå®
                if not is_http2_error:
                    print(f"  ‚ùå ÏöîÏ≤≠ Ïã§Ìå® (Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•Ìïú ÏóêÎü¨): {error_short}")
                    raise

                # HTTP2 ÏóêÎü¨Îäî 3ÌöåÍπåÏßÄ Ïû¨ÏãúÎèÑ
                print(f"  ‚ö†Ô∏è HTTP2 ÏóêÎü¨ (ÏãúÎèÑ {attempt}/{max_retries}): {error_short}")

                # ÎßàÏßÄÎßâ ÏãúÎèÑÏòÄÎã§Î©¥ ÏóêÎü¨ Î∞úÏÉù
                if attempt == max_retries:
                    print(f"\n  ‚ùå 3Ìöå Ïó∞ÏÜç Ïã§Ìå®Î°ú Ï¢ÖÎ£å\n")
                    raise

                # Îã§Ïùå Ïû¨ÏãúÎèÑ ÏïàÎÇ¥
                print(f"  ‚Üí 3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ...")

        if response_text is None:
            raise Exception(f"ÏùëÎãµÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§: {last_error}")

        try:
            # 4. ÏùëÎãµ Î∂ÑÏÑù
            print("[STEP 4] ÏùëÎãµ Î∂ÑÏÑù")
            print(f"  ÏÉÅÌÉú ÏΩîÎìú: {status_code}")
            print(f"  ÏùëÎãµ ÌÅ¨Í∏∞: {len(response_text):,} bytes")

            # Ï∞®Îã® Ïó¨Î∂Ä ÌôïÏù∏
            print("\n[STEP 5] Ï∞®Îã® Ïó¨Î∂Ä ÌôïÏù∏")

            blocked = False
            block_indicators = ['captcha', 'robot', 'access denied', 'blocked']

            response_lower = response_text.lower()
            for indicator in block_indicators:
                if indicator in response_lower:
                    print(f"  ‚ö†Ô∏è Ï∞®Îã® Í∞êÏßÄ: '{indicator}'")
                    blocked = True

            if not blocked:
                print("  ‚úì Ï∞®Îã® ÏóÜÏùå - Ï†ïÏÉÅ ÏùëÎãµ")

            # 6. ÏÉÅÌíà Ï†ïÎ≥¥ Ï∂îÏ∂ú
            print("\n[STEP 6] ÏÉÅÌíà Ï†ïÎ≥¥ Ï∂îÏ∂ú")

            extracted = ProductExtractor.extract_products_from_html(response_text)

            ranking_count = len(extracted['ranking'])
            ads_count = len(extracted['ads'])
            total_count = extracted['total']

            print(f"  Îû≠ÌÇπ ÏÉÅÌíà: {ranking_count}Í∞ú")
            print(f"  Í¥ëÍ≥† ÏÉÅÌíà: {ads_count}Í∞ú")
            print(f"  Ï†ÑÏ≤¥ ÏÉÅÌíà: {total_count}Í∞ú")

            if ranking_count > 0:
                print(f"\n  Îû≠ÌÇπ ÏÉÅÌíà ÏÉòÌîå (ÏµúÎåÄ 3Í∞ú):")
                for i, product in enumerate(extracted['ranking'][:3], 1):
                    print(f"    {i}. {product['name'][:40]}...")
                    print(f"       Í∞ÄÍ≤©: {product['price']}")
                    print(f"       ÏàúÏúÑ: {product['rank']}")
                    print(f"       ID: {product['uniqueKey'][:30]}...")

            # Akamai Ï∞®Îã® Í∞êÏßÄ
            is_akamai_blocked, akamai_challenge_type = self._detect_akamai_block(response)
            bm_sc_cookie = response.cookies.get('bm_sc', '') if hasattr(response, 'cookies') else ''

            if is_akamai_blocked:
                print(f"\n  ‚ö†Ô∏è Akamai Ï∞®Îã® Í∞êÏßÄ: {akamai_challenge_type}")
                if bm_sc_cookie:
                    print(f"     bm_sc Ïø†ÌÇ§: {bm_sc_cookie[:50]}...")

            # ÏÉÅÌíàÏùÑ DBÏóê Ï†ÄÏû• (ÏÑ±Í≥µ ÏãúÏóêÎßå)
            if status_code == 200 and not blocked and total_count > 0 and not is_akamai_blocked:
                try:
                    from lib.db.manager import DBManager
                    db = DBManager()

                    # ÏÉÅÌíà Î™©Î°ù Î≥ÄÌôò (Îû≠ÌÇπ + Í¥ëÍ≥†)
                    products_to_save = []

                    # Îû≠ÌÇπ ÏÉÅÌíà
                    for rank_product in extracted['ranking']:
                        products_to_save.append({
                            'type': 'ranking',
                            'name': rank_product.get('name'),
                            'price': rank_product.get('price'),
                            'url': rank_product.get('productUrl'),
                            'image_url': rank_product.get('imageUrl'),
                            'rank_position': rank_product.get('rank')
                        })

                    # Í¥ëÍ≥† ÏÉÅÌíà
                    for ad_product in extracted['ads']:
                        products_to_save.append({
                            'type': 'ad',
                            'name': ad_product.get('name'),
                            'price': ad_product.get('price'),
                            'url': ad_product.get('productUrl'),
                            'image_url': ad_product.get('imageUrl'),
                            'ad_slot': ad_product.get('adId'),
                            'ad_type': ad_product.get('adDisplayInfo', {}).get('groupName'),
                            'ad_position': ad_product.get('adDisplayInfo', {}).get('positionNumber')
                        })

                    # ÏùºÍ¥Ñ Ï†ÄÏû•
                    if products_to_save:
                        saved_count = db.save_products_batch(
                            session_id=self.session_id,
                            device_name=self.device_name,
                            browser=self.browser,
                            os_version=self.os_version,
                            keyword=keyword,
                            page_number=page,
                            products_list=products_to_save
                        )
                        print(f"  ‚úì ÏÉÅÌíà DB Ï†ÄÏû• ÏôÑÎ£å: {saved_count}Í∞ú")

                except Exception as e:
                    print(f"  ‚ö†Ô∏è ÏÉÅÌíà DB Ï†ÄÏû• Ïã§Ìå®: {e}")

            # Í≤∞Í≥º
            print("\n" + "="*60)
            if status_code == 200 and not blocked and total_count > 0:
                print("‚úÖ ÏÑ±Í≥µ! JA3 TLS FingerprintÎ°ú Ïø†Ìå° Í≤ÄÏÉâ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å")
                print("="*60)
                print(f"\n[ÌÅ¨Î°§ÎßÅ Í≤∞Í≥º]")
                print(f"  - Í≤ÄÏÉâ ÌÇ§ÏõåÎìú: {keyword}")
                print(f"  - ÌéòÏù¥ÏßÄ: {page}")
                print(f"  - Îû≠ÌÇπ ÏÉÅÌíà: {ranking_count}Í∞ú")
                print(f"  - Í¥ëÍ≥† ÏÉÅÌíà: {ads_count}Í∞ú")
                print(f"\n[Ï†ÅÏö©Îêú TLS Fingerprint]")
                print(f"  - JA3: {ja3[:60]}...")
                print(f"  - JA3 Hash: {tls_data.get('ja3_hash', 'N/A')}")
                if akamai:
                    print(f"  - Akamai: {akamai[:60]}...")
                print(f"  - Ïø†ÌÇ§: {len(cookie_dict)}Í∞ú")
                print(f"  - Ìó§Îçî: {len(headers)}Í∞ú")

                # ÏÑ∏ÏÖò Ïø†ÌÇ§ ÏÉÅÌÉú ÌôïÏù∏ (PCID, sid)
                cookies_status = {
                    'PCID': False,
                    'sid': False
                }
                if hasattr(self.session, 'cookies'):
                    cookies_status['PCID'] = 'PCID' in self.session.cookies
                    cookies_status['sid'] = 'sid' in self.session.cookies

                # ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïø†ÌÇ§Î•º DBÏóê Ï†ÄÏû• (ÏÑ±Í≥µ ÏãúÎßå)
                try:
                    from lib.db.manager import DBManager
                    import json

                    # Session Ïø†ÌÇ§Î•º dictÎ°ú Î≥ÄÌôò
                    session_cookies = []
                    if hasattr(self.session, 'cookies'):
                        for name, value in self.session.cookies.items():
                            session_cookies.append({
                                'name': name,
                                'value': value,
                                'domain': '.coupang.com'  # Í∏∞Î≥∏Í∞í
                            })

                    if session_cookies:
                        db = DBManager()
                        cookie_id = db.save_cookie(
                            device_name=self.device_name,
                            browser=self.browser,
                            os_version=self.os_version,
                            cookie_data=session_cookies,
                            cookie_type='updated',
                            session_id=self.session_id,
                            page_number=page
                        )
                        print(f"  ‚úì ÏóÖÎç∞Ïù¥Ìä∏ Ïø†ÌÇ§ DB Ï†ÄÏû• ÏôÑÎ£å (ID: {cookie_id}, ÌéòÏù¥ÏßÄ: {page})")

                except Exception as e:
                    print(f"  ‚ö†Ô∏è  Ïø†ÌÇ§ DB Ï†ÄÏû• Ïã§Ìå®: {e}")

                # ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• (ÏÑ±Í≥µ)
                try:
                    from lib.db.manager import DBManager
                    db = DBManager()

                    detail_data = {
                        'worker_id': self.worker_id,
                        'response_size_bytes': response_size_bytes,
                        'response_time_ms': response_time_ms,
                        'http_status_code': status_code,
                        'is_akamai_blocked': is_akamai_blocked,
                        'akamai_challenge_type': akamai_challenge_type,
                        'bm_sc_cookie': bm_sc_cookie,
                        'ranking_products_count': ranking_count,
                        'ad_products_count': ads_count,
                        'total_products_count': total_count,
                        'cookie_source': cookie_source,
                        'cookie_count': len(cookie_dict),
                        'has_pcid': cookies_status.get('PCID', False),
                        'has_sid': cookies_status.get('sid', False),
                        'attempt_number': attempt,
                        'max_attempts': max_retries
                    }

                    db.save_crawl_detail(
                        session_id=self.session_id,
                        device_name=self.device_name,
                        browser=self.browser,
                        os_version=self.os_version,
                        keyword=keyword,
                        page_number=page,
                        status='success',
                        detail_data=detail_data
                    )
                    print(f"  ‚úì ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ DB Ï†ÄÏû• ÏôÑÎ£å")

                except Exception as e:
                    print(f"  ‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• Ïã§Ìå®: {e}")

                return {
                    'success': True,
                    'keyword': keyword,
                    'page': page,
                    'ranking': extracted['ranking'],
                    'ads': extracted['ads'],
                    'total': total_count,
                    'cookies': cookies_status,
                    'html': response_text  # HTML Ï∂îÍ∞Ä (test_ad_rotation.pyÏö©)
                }
            else:
                print("‚ö†Ô∏è ÏùëÎãµ ÏàòÏã†ÌñàÏúºÎÇò Î¨∏Ï†ú Î∞úÏÉù")
                print("="*60)
                if blocked:
                    print("  - Ï∞®Îã® Í∞êÏßÄ")
                if total_count == 0:
                    print("  - ÏÉÅÌíà Ï†ïÎ≥¥ Ï∂îÏ∂ú Ïã§Ìå®")

                    # ÎîîÎ≤ÑÍπÖ: ÏùëÎãµ ÎÇ¥Ïö© ÏÉòÌîå Ï∂úÎ†•
                    print("\n  ÏùëÎãµ ÎÇ¥Ïö© ÎîîÎ≤ÑÍπÖ (Ï≤òÏùå 500Ïûê):")
                    print("  " + "-"*56)
                    preview = response_text[:500].replace('\n', '\n  ')
                    print(f"  {preview}")
                    print("  " + "-"*56)

                    # #productList ÎòêÎäî #product-list Ï°¥Ïû¨ ÌôïÏù∏
                    if '#productList' in response_text or '#product-list' in response_text or 'productList' in response_text:
                        print("\n  ‚ö†Ô∏è productList ÏöîÏÜåÎäî Ï°¥Ïû¨ÌïòÏßÄÎßå ÏÉÅÌíàÏù¥ Ï∂îÏ∂úÎêòÏßÄ ÏïäÏùå")
                    else:
                        print("\n  ‚ö†Ô∏è productList ÏöîÏÜåÍ∞Ä ÏùëÎãµÏóê ÏóÜÏùå (Ï∞®Îã® ÎòêÎäî Îπà ÌéòÏù¥ÏßÄ Í∞ÄÎä•ÏÑ±)")

                # Ï∞®Îã® Í∞êÏßÄ Ïãú Ïø†ÌÇ§ ÏÇ≠Ï†ú
                if blocked or total_count == 0:
                    delete_blocked_cookies(self.device_name, self.worker_id)
                    # Session Ïø†ÌÇ§Îäî ÏûêÎèô Í¥ÄÎ¶¨Îê® (Î¶¨ÏÖã Î∂àÌïÑÏöî)

                # ÏÑ∏ÏÖò Ïø†ÌÇ§ ÏÉÅÌÉú ÌôïÏù∏ (Ïã§Ìå® ÏãúÏóêÎèÑ Í∏∞Î°ù)
                cookies_status = {
                    'PCID': False,
                    'sid': False
                }
                if hasattr(self.session, 'cookies'):
                    cookies_status['PCID'] = 'PCID' in self.session.cookies
                    cookies_status['sid'] = 'sid' in self.session.cookies

                # ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• (Ïã§Ìå® - Ï∞®Îã® ÎòêÎäî ÏÉÅÌíà ÏóÜÏùå)
                try:
                    from lib.db.manager import DBManager
                    db = DBManager()

                    # ÏÉÅÌÉú Í≤∞Ï†ï
                    if is_akamai_blocked:
                        status = 'akamai_challenge'
                    elif blocked:
                        status = 'blocked'  # Îã§Î•∏ Ï∞®Îã® (captcha, robot Îì±)
                    elif total_count == 0:
                        status = 'no_products'
                    else:
                        status = 'unknown_error'

                    detail_data = {
                        'worker_id': self.worker_id,
                        'response_size_bytes': response_size_bytes,
                        'response_time_ms': response_time_ms,
                        'http_status_code': status_code,
                        'is_akamai_blocked': is_akamai_blocked,
                        'akamai_challenge_type': akamai_challenge_type,
                        'bm_sc_cookie': bm_sc_cookie,
                        'ranking_products_count': ranking_count,
                        'ad_products_count': ads_count,
                        'total_products_count': total_count,
                        'cookie_source': cookie_source,
                        'cookie_count': len(cookie_dict),
                        'has_pcid': cookies_status.get('PCID', False),
                        'has_sid': cookies_status.get('sid', False),
                        'attempt_number': attempt,
                        'max_attempts': max_retries
                    }

                    db.save_crawl_detail(
                        session_id=self.session_id,
                        device_name=self.device_name,
                        browser=self.browser,
                        os_version=self.os_version,
                        keyword=keyword,
                        page_number=page,
                        status=status,
                        detail_data=detail_data
                    )
                    print(f"  ‚úì ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ DB Ï†ÄÏû• ÏôÑÎ£å (ÏÉÅÌÉú: {status})")

                except Exception as e:
                    print(f"  ‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• Ïã§Ìå®: {e}")

                return {
                    'success': False,
                    'keyword': keyword,
                    'page': page,
                    'error': 'blocked' if blocked else 'no_products',
                    'cookies': cookies_status,
                    'html': response_text  # HTML Ï∂îÍ∞Ä (Ï∞®Îã®/Îπà ÌéòÏù¥ÏßÄ ÎîîÎ≤ÑÍπÖÏö©)
                }

        except Exception as e:
            error_short = str(e)[:80] if len(str(e)) > 80 else str(e)
            print(f"\n  ‚ùå Ï≤òÎ¶¨ Ïã§Ìå®: {error_short}")

            # ÏÑ∏ÏÖò Ïø†ÌÇ§ ÏÉÅÌÉú ÌôïÏù∏ (ÏóêÎü¨ ÏãúÏóêÎèÑ Í∏∞Î°ù)
            cookies_status = {
                'PCID': False,
                'sid': False
            }
            if hasattr(self.session, 'cookies'):
                cookies_status['PCID'] = 'PCID' in self.session.cookies
                cookies_status['sid'] = 'sid' in self.session.cookies

            # ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• (ÏòàÏô∏ Î∞úÏÉù)
            try:
                from lib.db.manager import DBManager
                db = DBManager()

                # ÏóêÎü¨ ÌÉÄÏûÖ Î∂ÑÎ•ò
                error_type = self._classify_error(e)

                # Î≥ÄÏàòÍ∞Ä Ï†ïÏùòÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
                detail_data = {
                    'worker_id': self.worker_id,
                    'error_message': str(e),
                    'error_type': error_type,
                    'response_size_bytes': response_size_bytes if 'response_size_bytes' in locals() else None,
                    'response_time_ms': response_time_ms if 'response_time_ms' in locals() else None,
                    'http_status_code': status_code if 'status_code' in locals() else None,
                    'is_akamai_blocked': False,
                    'ranking_products_count': 0,
                    'ad_products_count': 0,
                    'total_products_count': 0,
                    'cookie_source': cookie_source if 'cookie_source' in locals() else 'none',
                    'cookie_count': len(cookie_dict) if 'cookie_dict' in locals() else 0,
                    'has_pcid': cookies_status.get('PCID', False),
                    'has_sid': cookies_status.get('sid', False),
                    'attempt_number': attempt if 'attempt' in locals() else 1,
                    'max_attempts': max_retries
                }

                db.save_crawl_detail(
                    session_id=self.session_id,
                    device_name=self.device_name,
                    browser=self.browser,
                    os_version=self.os_version,
                    keyword=keyword,
                    page_number=page,
                    status=error_type,
                    detail_data=detail_data
                )
                print(f"  ‚úì ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ DB Ï†ÄÏû• ÏôÑÎ£å (ÏóêÎü¨: {error_type})")

            except Exception as db_error:
                print(f"  ‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑ∏Î∂Ä Ï†ïÎ≥¥ Ï†ÄÏû• Ïã§Ìå®: {db_error}")

            return {
                'success': False,
                'keyword': keyword,
                'page': page,
                'error': str(e),
                'cookies': cookies_status,
                'html': ''  # ÏòàÏô∏ Î∞úÏÉù Ïãú Îπà HTML
            }

    def crawl_pages(self, keyword='ÏïÑÏù¥Ìè∞', start_page=1, end_page=1, use_checkpoint=True):
        """
        Îã§Ï§ë ÌéòÏù¥ÏßÄ ÌÅ¨Î°§ÎßÅ

        Args:
            keyword: Í≤ÄÏÉâ ÌÇ§ÏõåÎìú
            start_page: ÏãúÏûë ÌéòÏù¥ÏßÄ
            end_page: Ï¢ÖÎ£å ÌéòÏù¥ÏßÄ
            use_checkpoint: Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÏÇ¨Ïö© Ïó¨Î∂Ä (Í∏∞Î≥∏: True)

        Returns:
            dict: {
                'success': bool,
                'results': list,  # ÌÅ¨Î°§ÎßÅ Í≤∞Í≥º Î¶¨Ïä§Ìä∏
                'need_refresh': bool,  # Ïø†ÌÇ§ Ïû¨ÏàòÏßë ÌïÑÏöî Ïó¨Î∂Ä
                'last_page': int  # ÎßàÏßÄÎßâ ÏãúÎèÑ ÌéòÏù¥ÏßÄ
            }
        """

        print("\n" + "="*70)
        print(f"Îã§Ï§ë ÌéòÏù¥ÏßÄ ÌÅ¨Î°§ÎßÅ: {start_page} ~ {end_page} ÌéòÏù¥ÏßÄ")
        print(f"(Fingerprint Ïø†ÌÇ§ + ÏÑ∏ÏÖò Ïø†ÌÇ§ ÎèôÏ†Å Í¥ÄÎ¶¨)")
        print("="*70)

        # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï¥àÍ∏∞Ìôî
        checkpoint = None
        if use_checkpoint and not self.worker_id:  # Worker Î™®ÎìúÏóêÏÑúÎäî Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÎπÑÌôúÏÑ±Ìôî
            checkpoint = Checkpoint(keyword, self.device_name, self.browser, start_page, end_page)

            # Í∏∞Ï°¥ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Î°úÎìú
            if checkpoint.load():
                summary = checkpoint.get_summary()
                print(f"\nüìã Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Î∞úÍ≤¨: {summary['progress']} ({summary['percentage']})")
                print(f"   ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏: {summary['last_updated']}")

                if checkpoint.is_completed():
                    print(f"‚úÖ Ïù¥ÎØ∏ Î™®Îì† ÌéòÏù¥ÏßÄ ÏôÑÎ£åÎê®")
                    # ÏôÑÎ£åÎêú Í≤∞Í≥º Î∞òÌôò
                    return {
                        'success': True,
                        'results': [],
                        'need_refresh': False,
                        'last_page': end_page,
                        'from_checkpoint': True
                    }

                remaining = checkpoint.get_remaining_pages()
                print(f"   ÎÇ®ÏùÄ ÌéòÏù¥ÏßÄ: {remaining[:10]}{'...' if len(remaining) > 10 else ''}")
            else:
                print(f"\nüìã ÏÉà Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÏÉùÏÑ±")

        # Session Ïø†ÌÇ§Îäî ÏûêÎèô Í¥ÄÎ¶¨Îê® (Ï¥àÍ∏∞Ìôî Î∂àÌïÑÏöî)
        print(f"\nÏÉà ÌÅ¨Î°§ÎßÅ ÏÑ∏ÏÖò ÏãúÏûë - SessionÏù¥ Ïø†ÌÇ§ ÏûêÎèô Í¥ÄÎ¶¨\n")

        all_results = []
        consecutive_failures = 0

        for page in range(start_page, end_page + 1):
            # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏: Ïù¥ÎØ∏ ÏôÑÎ£åÎêú ÌéòÏù¥ÏßÄ Ïä§ÌÇµ
            if checkpoint and page in checkpoint.get_completed_pages():
                print(f"\n‚è≠Ô∏è  ÌéòÏù¥ÏßÄ {page} Ïä§ÌÇµ (Ïù¥ÎØ∏ ÏôÑÎ£å)")
                continue

            # ÌéòÏù¥ÏßÄÎ≥Ñ Ïû¨ÏãúÎèÑ Î°úÏßÅ (ÏµúÎåÄ 3Ìöå)
            page_max_retries = 3
            page_result = None

            for attempt in range(1, page_max_retries + 1):
                result = self.crawl_page(keyword=keyword, page=page)

                if not result:
                    print(f"\n‚ö†Ô∏è ÌéòÏù¥ÏßÄ {page} ÌÅ¨Î°§ÎßÅ Ïã§Ìå® - Ï§ëÎã®")
                    # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Î∞òÌôò (Ïû¨ÏãúÎèÑÏö©)
                    return {
                        'success': False,
                        'results': all_results,
                        'need_refresh': True,
                        'last_page': page
                    }

                # ÏÑ±Í≥µ Ïãú Ïû¨ÏãúÎèÑ Î£®ÌîÑ Ï¢ÖÎ£å
                if result.get('success'):
                    page_result = result
                    break

                # Ïã§Ìå® Ï≤òÎ¶¨
                error_type = result.get('error', 'unknown')

                # Ï∞®Îã® Í∞êÏßÄ Ïãú Ïû¨ÏãúÎèÑ
                if error_type in ['blocked', 'no_products']:
                    if attempt < page_max_retries:
                        print(f"\n  ‚ö†Ô∏è Ï∞®Îã® Í∞êÏßÄ (ÏãúÎèÑ {attempt}/{page_max_retries})")
                        print(f"  ‚Üí 3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ...")
                        time.sleep(3)
                        continue  # Îã§Ïùå Ïû¨ÏãúÎèÑ
                    else:
                        # 3Ìöå Ïó∞ÏÜç Ï∞®Îã® Ïãú ÏµúÏ¢Ö Ïã§Ìå®
                        print(f"\n  ‚ùå {page_max_retries}Ìöå Ïó∞ÏÜç Ï∞®Îã®ÏúºÎ°ú Ï¢ÖÎ£å")
                        page_result = result
                        break
                else:
                    # Îã§Î•∏ ÏóêÎü¨Îäî Ïû¨ÏãúÎèÑ ÏóÜÏù¥ Î∞îÎ°ú Ïã§Ìå®
                    page_result = result
                    break

            # ÏµúÏ¢Ö Í≤∞Í≥º Ï≤òÎ¶¨
            all_results.append(page_result)

            if page_result.get('success'):
                print(f"\n‚úÖ ÌéòÏù¥ÏßÄ {page} ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å")
                consecutive_failures = 0  # ÏÑ±Í≥µ Ïãú Ïó∞ÏÜç Ïã§Ìå® Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã

                # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•
                if checkpoint:
                    checkpoint.add_result(page, page_result)
                    print(f"   üíæ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•Îê® ({checkpoint.get_summary()['progress']})")

            else:
                consecutive_failures += 1
                error_type = page_result.get('error', 'unknown')
                print(f"\n‚ùå ÌéòÏù¥ÏßÄ {page} ÌÅ¨Î°§ÎßÅ Ïã§Ìå® ({error_type})")

                # Ï∞®Îã® Í∞êÏßÄ Ïãú (3Ìöå Ïû¨ÏãúÎèÑ ÌõÑÏóêÎèÑ Ïã§Ìå®)
                if error_type in ['blocked', 'no_products']:
                    print(f"\n{'='*70}")
                    print("‚ö†Ô∏è Ï∞®Îã® Í∞êÏßÄ - Ïø†ÌÇ§ Ïû¨ÏàòÏßë ÌïÑÏöî")
                    print("="*70)

                    if checkpoint:
                        summary = checkpoint.get_summary()
                        print(f"  üìä ÌòÑÏû¨ ÏßÑÌñâÎ•†: {summary['progress']} ({summary['percentage']})")
                        print(f"  üîÑ Ïû¨ÏãúÎèÑ Ïãú ÌéòÏù¥ÏßÄ {page}Î∂ÄÌÑ∞ Ïû¨Í∞úÎê©ÎãàÎã§")

                    print("="*70)

                    # Ïø†ÌÇ§ Ïû¨ÏàòÏßë ÌïÑÏöî Ïã†Ìò∏ Î∞òÌôò
                    return {
                        'success': False,
                        'results': all_results,
                        'need_refresh': True,
                        'last_page': page
                    }

                # Ïó∞ÏÜç 2Ìöå Ïã§Ìå® Ïãú Ï§ëÎã®
                if consecutive_failures >= 2:
                    print(f"\n‚ö†Ô∏è Ïó∞ÏÜç {consecutive_failures}Ìöå Ïã§Ìå® - ÌÅ¨Î°§ÎßÅ Ï§ëÎã®")
                    return {
                        'success': False,
                        'results': all_results,
                        'need_refresh': True,
                        'last_page': page
                    }

                # Îã®Ïùº Ïã§Ìå®Îäî Í≥ÑÏÜç ÏßÑÌñâ
                print(f"  Îã§Ïùå ÌéòÏù¥ÏßÄÎ°ú Í≥ÑÏÜç ÏãúÎèÑÌï©ÎãàÎã§...")

            # Îã§Ïùå ÌéòÏù¥ÏßÄÎ°ú ÎÑòÏñ¥Í∞ÄÍ∏∞ Ï†Ñ ÎûúÎç§ ÎîúÎ†àÏù¥ (ÏÇ¨ÎûåÏ≤òÎüº ÌñâÎèô)
            if page < end_page:
                import random
                delay = random.uniform(1.5, 2.5)
                print(f"\n‚è≥ Îã§Ïùå ÌéòÏù¥ÏßÄ ÎåÄÍ∏∞ Ï§ë... ({delay:.1f}Ï¥à)")
                time.sleep(delay)

        # Î™®Îì† ÌéòÏù¥ÏßÄ ÏôÑÎ£å
        return {
            'success': True,
            'results': all_results,
            'need_refresh': False,
            'last_page': end_page
        }

    # ==========================================
    # Î∂ÑÏÑùÏö© Helper Methods
    # ==========================================

    def _detect_akamai_block(self, response):
        """
        Akamai Ï∞®Îã® Ïó¨Î∂Ä Í∞êÏßÄ

        Args:
            response: curl_cffi response Í∞ùÏ≤¥

        Returns:
            tuple: (is_blocked, challenge_type)
                is_blocked: bool - Ï∞®Îã® Ïó¨Î∂Ä
                challenge_type: str - Ï±åÎ¶∞ÏßÄ ÌÉÄÏûÖ ('bm_sc_challenge', 'akamai_page', 'no_products_suspicious', None)
        """
        # 1. ÏùëÎãµ ÌÅ¨Í∏∞Í∞Ä ÏûëÏúºÎ©¥ ÏùòÏã¨
        response_size = len(response.content) if hasattr(response, 'content') else len(response.text)

        if response_size < 5000:  # 5KB ÎØ∏Îßå
            # bm_sc Ïø†ÌÇ§ Ï°¥Ïû¨ ÌôïÏù∏ (Akamai Bot Manager)
            if hasattr(response, 'cookies') and 'bm_sc' in response.cookies:
                return True, 'bm_sc_challenge'

            # ÏùëÎãµ ÌÖçÏä§Ìä∏ÏóêÏÑú Akamai Îã®Ïñ¥ ÌôïÏù∏
            response_text = response.text.lower()
            if 'akamai' in response_text:
                return True, 'akamai_page'

            # ÏÉÅÌíà Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ ÏùòÏã¨
            if 'class="search-product"' not in response.text and 'data-component-type' not in response.text:
                return True, 'no_products_suspicious'

        return False, None

    def _classify_error(self, exception):
        """
        ÏóêÎü¨ ÌÉÄÏûÖ Î∂ÑÎ•ò

        Args:
            exception: Exception Í∞ùÏ≤¥

        Returns:
            str: ÏóêÎü¨ ÌÉÄÏûÖ
                - 'http2_error'
                - 'network_error'
                - 'timeout'
                - 'parsing_error'
                - 'unknown_error'
        """
        error_str = str(exception).lower()

        if 'http2' in error_str or 'internal_error' in error_str or 'stream' in error_str or 'protocol' in error_str:
            return 'http2_error'
        elif 'timeout' in error_str or 'timed out' in error_str:
            return 'timeout'
        elif 'connection' in error_str or 'network' in error_str:
            return 'network_error'
        elif 'parse' in error_str or 'json' in error_str or 'html' in error_str:
            return 'parsing_error'
        else:
            return 'unknown_error'
